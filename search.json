[
  {
    "objectID": "version_upload_file.html",
    "href": "version_upload_file.html",
    "title": "Entropia",
    "section": "",
    "text": "library(shiny)\n\nWarning: package 'shiny' was built under R version 4.2.3\n\nlibrary(bslib)\n\nWarning: package 'bslib' was built under R version 4.2.3\n\n\n\nAttaching package: 'bslib'\n\n\nThe following object is masked from 'package:utils':\n\n    page\n\n# Define UI for slider demo app ----\nui &lt;- page_sidebar(\n\n  # App title ----\n  title = \"Subir Archivo\",\n\n  # Sidebar panel for inputs ----\n  sidebar = sidebar(\n\n    # Input: Select a file ----\n    fileInput(\n      \"file1\",\n      \"Choose CSV File\",\n      multiple = TRUE,\n      accept = c(\n        \"text/csv\",\n        \"text/comma-separated-values,text/plain\",\n        \".csv\"\n      )\n    ),\n\n    # Horizontal line ----\n    tags$hr(),\n\n    # Input: Checkbox if file has header ----\n    checkboxInput(\"header\", \"Header\", TRUE),\n\n    # Input: Select separator ----\n    radioButtons(\n      \"sep\",\n      \"Separator\",\n      choices = c(\n        Comma = \",\",\n        Semicolon = \";\",\n        Tab = \"\\t\"\n      ),\n      selected = \",\"\n    ),\n\n    # Input: Select quotes ----\n    radioButtons(\n      \"quote\",\n      \"Quote\",\n      choices = c(\n        None = \"\",\n        \"Double Quote\" = '\"',\n        \"Single Quote\" = \"'\"\n      ),\n      selected = '\"'\n    ),\n\n    # Horizontal line ----\n    tags$hr(),\n\n    # Input: Select number of rows to display ----\n    radioButtons(\n      \"disp\",\n      \"Display\",\n      choices = c(\n        Head = \"head\",\n        All = \"all\"\n      ),\n      selected = \"head\"\n    )\n  ),\n\n  # Output: Data file ----\n  tableOutput(\"contents\")\n)\n\n# Define server logic to read selected file ----\nserver &lt;- function(input, output) {\n  output$contents &lt;- renderTable({\n    # input$file1 will be NULL initially. After the user selects\n    # and uploads a file, head of that data file by default,\n    # or all rows if selected, will be shown.\n\n    req(input$file1)\n\n    df &lt;- read.csv(\n      input$file1$datapath,\n      header = input$header,\n      sep = input$sep,\n      quote = input$quote\n    )\n\n    if (input$disp == \"head\") {\n      return(head(df))\n    } else {\n      return(df)\n    }\n  })\n}\n\n# Create Shiny app ----\nshinyApp(ui, server)\n\n\nListening on http://127.0.0.1:4215\n\n\n\n\n\n\n\n\n\nmpgData &lt;- readr::read_csv(‚Äúwater_maze.csv‚Äù)\nmpgData |&gt; dplyr::select(prueba, distancioa_media_blanco, zona_blanco)\nwebr::install(‚Äúggplot2‚Äù) webr::install(‚Äúhtmltools‚Äù)\nhttps://shinylive.io/r/examples/#sliders\nhttps://rstudio.github.io/renv/articles/renv.html\nhttps://quarto.thecoatlessprofessor.com/r-shinylive-demo/\nhttps://github.com/coatless-tutorials/convert-shiny-app-r-shinylive/blob/main/app.R\nhttps://github.com/coatless-textbooks/statistical-concepts-with-shiny-apps/blob/main/index.qmd\nhttps://shiny.posit.co/r/gallery/\nv2\n\nlibrary(shiny)\nlibrary(bslib)\n\n# Define UI for slider demo app ----\nui &lt;- page_sidebar(\n\n  # App title ----\n  title = \"Subir Archivo\",\n\n  # Sidebar panel for inputs ----\n  sidebar = sidebar(\n\n    # Input: Select a file ----\n    fileInput(\n      \"file1\",\n      \"Choose CSV File\",\n      multiple = TRUE,\n      accept = c(\n        \"text/csv\",\n        \"text/comma-separated-values,text/plain\",\n        \".csv\"\n      )\n    ),\n\n    # Horizontal line ----\n    tags$hr(),\n\n    # Input: Checkbox if file has header ----\n    checkboxInput(\"header\", \"Header\", TRUE),\n\n    # Input: Select separator ----\n    # radioButtons(\n    #   \"sep\",\n    #   \"Separator\",\n    #   choices = c(\n    #     Comma = \",\",\n    #     Semicolon = \";\",\n    #     Tab = \"\\t\"\n    #   ),\n    #   selected = \",\"\n    # ),\n\n    # Input: Select quotes ----\n    # radioButtons(\n    #   \"quote\",\n    #   \"Quote\",\n    #   choices = c(\n    #     None = \"\",\n    #     \"Double Quote\" = '\"',\n    #     \"Single Quote\" = \"'\"\n    #   ),\n    #   selected = '\"'\n    # ),\n\n    # Horizontal line ----\n    tags$hr(),\n\n    # Input: Select number of rows to display ----\n    radioButtons(\n      \"disp\",\n      \"Display\",\n      choices = c(\n        Head = \"head\",\n        All = \"all\"\n      ),\n      selected = \"head\"\n    )\n  ),\n  \n  navset_card_underline(\n    # Panel with plot ----\n    nav_panel(\"Plot\", plotOutput(\"plot\")),\n\n    # Panel with summary ----\n    nav_panel(\"Summary\", verbatimTextOutput(\"summary\")),\n\n    # Panel with table ----\n    nav_panel(\"Table\", tableOutput(\"contents\"))\n  )\n\n)\n\n# Define server logic to read selected file ----\nserver &lt;- function(input, output) {\n  output$contents &lt;- renderTable({\n    # input$file1 will be NULL initially. After the user selects\n    # and uploads a file, head of that data file by default,\n    # or all rows if selected, will be shown.\n\n    req(input$file1)\n\n    df &lt;- read.csv(\n      input$file1$datapath,\n      header = input$header\n      # sep = input$sep,\n      # quote = input$quote\n    )\n\n    if (input$disp == \"head\") {\n      return(head(df))\n    } else {\n      return(df)\n    }\n  })\n  # \n  output$plot &lt;- renderPlot({\n    req(input$file1)\n    hist(\n      df(),\n      lty = \"blank\",\n      xlab = \"cruces_blanco\",\n      freq = FALSE,\n      main = \"\",\n      col = \"#75AADB\",\n      border = \"white\"\n    )\n  })\n\n  # Generate a summary of the data ----\n  output$summary &lt;- renderPrint({\n    summary((df))\n  })\n}\n\n# Create Shiny app ----\nshinyApp(ui, server)\n\n\nListening on http://127.0.0.1:8099"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "C√°lculo de Entropia en el Laberinto Acu√°tico de Morris",
    "section": "",
    "text": "Coordenadas de annulus original: (117.8, 38.4). Coordenadas de annulus Reversa: (61.8, 89.6). NOTA: Las coordenadas del animal y del aparato est√°n en cent√≠metros. Se pueden usar mm, pixeles o lo que se requiera, aunque puedan cambiar las unidades de entrop√≠a, pero seguir√°n siendo equivalentes y proporcionales siempre y cuando se use la misma unidad. Se recomienda hace un poco m√°s grande el radio del aparato para graficar (esto no afecta el c√°lculo de H). Ejemplo de archivos para esta app en este enlace y en este enlace.\n#| standalone: true\n#| viewerHeight: 600\nlibrary(shiny)\nlibrary(janitor)  # For clean_names\nlibrary(dplyr)    # For data manipulation\nlibrary(car)      # For the ellipse function\n\n# Define UI for app to upload and analyze CSV file\nui &lt;- fluidPage(\n  titlePanel(\"C√°lculo de entrop√≠a\"),\n  sidebarLayout(\n    sidebarPanel(\n      # Input: Select a CSV file\n      fileInput(\"file1\", \"Subir coordenadas\", accept = \".csv\"),\n      \n      # Numeric input for defining platform (plat_x, plat_y)\n      numericInput(\"plat_x\", \"Coordenadas de plataforma en X\", value = 117.8,),  # Default value\n      numericInput(\"plat_y\", \"Coordenadas de plataforma en Y\", value = 38.4),   # Default value\n\n      # Numeric input for defining the center (wm_centr_x, wm_centr_y)\n      numericInput(\"wm_centr_x\", \"Centro en X del aparato\", value = 90.13),  # Default value\n      numericInput(\"wm_centr_y\", \"Centro en Y del aparato\", value = 61.3),  # Default value\n      \n      # Numeric input for defining the radius of the Annulus\n      numericInput(\"radio_wm\", \"Radio del aparato\", value = 65),  # Default value\n      \n      tags$hr(),\n      \n      # Button to calculate entropy\n      actionButton(\"calc_entropy\", \"Calcular H\")\n    ),\n    mainPanel(\n      tableOutput(\"entropy_table\"),  # Display entropy\n      plotOutput(\"plot\")             # Display plot\n    )\n  )\n)\n\n# Define server logic\nserver &lt;- function(input, output, session) {\n  observeEvent(input$calc_entropy, {\n    req(input$file1)  # Ensure that a file is uploaded before proceeding\n    \n    # Read the CSV file\n    data &lt;- read.csv(input$file1$datapath)\n    # Clean column names with janitor to ensure consistency\n    data &lt;- janitor::clean_names(data) %&gt;%\n        dplyr::slice(2:n())  # Remove the first row if it contains 0,0\n    # Rename the first three columns to 'time', 'X', 'Y'\n    names(data)[1:3] &lt;- c(\"time\", \"X\", \"Y\")\n    \n    # Use input values for platform and center coordinates\n    plat_x &lt;- input$plat_x\n    plat_y &lt;- input$plat_y\n    wm_centr_x &lt;- input$wm_centr_x\n    wm_centr_y &lt;- input$wm_centr_y\n    radio_wm &lt;- input$radio_wm\n\n    Xraw &lt;- as.numeric(data$X)\n    Yraw &lt;- as.numeric(data$Y)\n\n    # Calculate differences between platform and raw data\n    d_x &lt;- Xraw - plat_x\n    d_y &lt;- Yraw - plat_y\n\n    dist2 &lt;- d_x^2 + d_y^2\n\n    # Entropy calculation\n    w &lt;- 1\n    sw &lt;- sum(w)\n\n    xm &lt;- mean(w * d_x) / sw\n    ym &lt;- mean(w * d_y) / sw\n    xxm &lt;- mean(w * d_x * d_x) / sw\n    yym &lt;- mean(w * d_y * d_y) / sw\n    xym &lt;- mean(w * d_x * d_y) / sw\n\n    Sig &lt;- matrix(c(xxm - xm^2, xym - xm * ym,\n                    xym - xm * ym, yym - ym^2), nrow=2)\n\n    eig_val &lt;- eigen(Sig)$values\n    var_xy2 &lt;- eig_val[1] * eig_val[2]\n\n    mdist2 &lt;- mean(w * dist2) / sw\n\n    entropy &lt;- log(mdist2) + 0.5 * log(var_xy2)\n\n    # Create a data frame for output\n    entropy_data &lt;- data.frame(Entropia = entropy)\n\n    # Output the data frame\n    output$entropy_table &lt;- renderTable({\n      entropy_data\n    })\n\n    # Output the plot\n    output$plot &lt;- renderPlot({\n      # Define limits with a buffer around the annulus\n      x_lim_buffer &lt;- radio_wm + 20\n      y_lim_buffer &lt;- radio_wm + 20\n      \n      # Set up the plot window\n      plot(Xraw, Yraw, pch = 4, col = \"#3F4E4F\", xlim = c(wm_centr_x - x_lim_buffer, wm_centr_x + x_lim_buffer), ylim = c(wm_centr_y - y_lim_buffer, wm_centr_y + y_lim_buffer), xlab = \"X\", ylab = \"Y\", main = \"Coordenadas del rat√≥n alrededor del Annulus blanco\")\n      \n      # Draw the annulus (circle) using base R\n      symbols(wm_centr_x, wm_centr_y, circles = radio_wm, add = TRUE, inches = FALSE, fg = \"black\", bg = \"#98DED9\")\n      \n      # Plot the platform as a red point\n      points(plat_x, plat_y, col = \"red\", pch = 19, cex = 1.5)\n      text(plat_x + 15, plat_y - 20, labels = \"Plataforma\", col = \"red\")\n      \n      # Draw lines from each point to the platform\n      segments(Xraw, Yraw, plat_x, plat_y, col = \"#3F4E4F\", lty = 3)\n    })\n  })\n}\n\n# Create Shiny app\nshinyApp(ui, server)"
  },
  {
    "objectID": "index.html#c√°lculo",
    "href": "index.html#c√°lculo",
    "title": "C√°lculo de Entropia en el Laberinto Acu√°tico de Morris",
    "section": "",
    "text": "Coordenadas de annulus original: (117.8, 38.4). Coordenadas de annulus Reversa: (61.8, 89.6). NOTA: Las coordenadas del animal y del aparato est√°n en cent√≠metros. Se pueden usar mm, pixeles o lo que se requiera, aunque puedan cambiar las unidades de entrop√≠a, pero seguir√°n siendo equivalentes y proporcionales siempre y cuando se use la misma unidad. Se recomienda hace un poco m√°s grande el radio del aparato para graficar (esto no afecta el c√°lculo de H). Ejemplo de archivos para esta app en este enlace y en este enlace.\n#| standalone: true\n#| viewerHeight: 600\nlibrary(shiny)\nlibrary(janitor)  # For clean_names\nlibrary(dplyr)    # For data manipulation\nlibrary(car)      # For the ellipse function\n\n# Define UI for app to upload and analyze CSV file\nui &lt;- fluidPage(\n  titlePanel(\"C√°lculo de entrop√≠a\"),\n  sidebarLayout(\n    sidebarPanel(\n      # Input: Select a CSV file\n      fileInput(\"file1\", \"Subir coordenadas\", accept = \".csv\"),\n      \n      # Numeric input for defining platform (plat_x, plat_y)\n      numericInput(\"plat_x\", \"Coordenadas de plataforma en X\", value = 117.8,),  # Default value\n      numericInput(\"plat_y\", \"Coordenadas de plataforma en Y\", value = 38.4),   # Default value\n\n      # Numeric input for defining the center (wm_centr_x, wm_centr_y)\n      numericInput(\"wm_centr_x\", \"Centro en X del aparato\", value = 90.13),  # Default value\n      numericInput(\"wm_centr_y\", \"Centro en Y del aparato\", value = 61.3),  # Default value\n      \n      # Numeric input for defining the radius of the Annulus\n      numericInput(\"radio_wm\", \"Radio del aparato\", value = 65),  # Default value\n      \n      tags$hr(),\n      \n      # Button to calculate entropy\n      actionButton(\"calc_entropy\", \"Calcular H\")\n    ),\n    mainPanel(\n      tableOutput(\"entropy_table\"),  # Display entropy\n      plotOutput(\"plot\")             # Display plot\n    )\n  )\n)\n\n# Define server logic\nserver &lt;- function(input, output, session) {\n  observeEvent(input$calc_entropy, {\n    req(input$file1)  # Ensure that a file is uploaded before proceeding\n    \n    # Read the CSV file\n    data &lt;- read.csv(input$file1$datapath)\n    # Clean column names with janitor to ensure consistency\n    data &lt;- janitor::clean_names(data) %&gt;%\n        dplyr::slice(2:n())  # Remove the first row if it contains 0,0\n    # Rename the first three columns to 'time', 'X', 'Y'\n    names(data)[1:3] &lt;- c(\"time\", \"X\", \"Y\")\n    \n    # Use input values for platform and center coordinates\n    plat_x &lt;- input$plat_x\n    plat_y &lt;- input$plat_y\n    wm_centr_x &lt;- input$wm_centr_x\n    wm_centr_y &lt;- input$wm_centr_y\n    radio_wm &lt;- input$radio_wm\n\n    Xraw &lt;- as.numeric(data$X)\n    Yraw &lt;- as.numeric(data$Y)\n\n    # Calculate differences between platform and raw data\n    d_x &lt;- Xraw - plat_x\n    d_y &lt;- Yraw - plat_y\n\n    dist2 &lt;- d_x^2 + d_y^2\n\n    # Entropy calculation\n    w &lt;- 1\n    sw &lt;- sum(w)\n\n    xm &lt;- mean(w * d_x) / sw\n    ym &lt;- mean(w * d_y) / sw\n    xxm &lt;- mean(w * d_x * d_x) / sw\n    yym &lt;- mean(w * d_y * d_y) / sw\n    xym &lt;- mean(w * d_x * d_y) / sw\n\n    Sig &lt;- matrix(c(xxm - xm^2, xym - xm * ym,\n                    xym - xm * ym, yym - ym^2), nrow=2)\n\n    eig_val &lt;- eigen(Sig)$values\n    var_xy2 &lt;- eig_val[1] * eig_val[2]\n\n    mdist2 &lt;- mean(w * dist2) / sw\n\n    entropy &lt;- log(mdist2) + 0.5 * log(var_xy2)\n\n    # Create a data frame for output\n    entropy_data &lt;- data.frame(Entropia = entropy)\n\n    # Output the data frame\n    output$entropy_table &lt;- renderTable({\n      entropy_data\n    })\n\n    # Output the plot\n    output$plot &lt;- renderPlot({\n      # Define limits with a buffer around the annulus\n      x_lim_buffer &lt;- radio_wm + 20\n      y_lim_buffer &lt;- radio_wm + 20\n      \n      # Set up the plot window\n      plot(Xraw, Yraw, pch = 4, col = \"#3F4E4F\", xlim = c(wm_centr_x - x_lim_buffer, wm_centr_x + x_lim_buffer), ylim = c(wm_centr_y - y_lim_buffer, wm_centr_y + y_lim_buffer), xlab = \"X\", ylab = \"Y\", main = \"Coordenadas del rat√≥n alrededor del Annulus blanco\")\n      \n      # Draw the annulus (circle) using base R\n      symbols(wm_centr_x, wm_centr_y, circles = radio_wm, add = TRUE, inches = FALSE, fg = \"black\", bg = \"#98DED9\")\n      \n      # Plot the platform as a red point\n      points(plat_x, plat_y, col = \"red\", pch = 19, cex = 1.5)\n      text(plat_x + 15, plat_y - 20, labels = \"Plataforma\", col = \"red\")\n      \n      # Draw lines from each point to the platform\n      segments(Xraw, Yraw, plat_x, plat_y, col = \"#3F4E4F\", lty = 3)\n    })\n  })\n}\n\n# Create Shiny app\nshinyApp(ui, server)"
  },
  {
    "objectID": "index.html#ejemplo-de-la-funci√≥n-ejecutada-en-r",
    "href": "index.html#ejemplo-de-la-funci√≥n-ejecutada-en-r",
    "title": "C√°lculo de Entropia en el Laberinto Acu√°tico de Morris",
    "section": "Ejemplo de la funci√≥n ejecutada en R",
    "text": "Ejemplo de la funci√≥n ejecutada en R\n\n\n\nEjemplo del c√°lculo de entropia ejectuado en R\n\n\nDebido a las limitaciones de shinylive, se recomienda bajar el c√≥digo fuente original (disponible en este repositorio) y ejecutarlo desde RStudio.\nEl script est√° dise√±ado para ser ejecutado en solo tres pasos:\n\nCorrer la funci√≥n.\nEspecificar el directorio del archivo a analizar. El archivo tiene que tener las siguientes caracter√≠sticas: formato CVS; 3 columnas (tiempo [en segundos], X [en cm], Y [en cm]). NOTA, se pude hacer con las coordenadas en mm, pulgadas‚Ä¶etc, pero se tiene que ajustar la funci√≥n en caso de no proveer en cent√≠metros Ver aqu√≠ ejemplo de archivo.\nLllamar a la funci√≥n especificando, en orden, las coordenadas de la plataforma en x, y, el centro del water maze en x, y, radio del water maze en cm. Ejemplo: calculate_entropy_and_plot(file_path, 117.8, 38.4, 90.13, 61.3, 65, reversa = FALSE)\nEn caso de ser una prueba reversa, se debe a√±adir las coordenadas reversa: calculate_entropy_and_plot(file_path, 117.8, 38.4, 90.13, 61.3, 65, reversa = TRUE, plat_x_rev = 61.8, plat_y_rev = 89.6) para obtener el siguiente gr√°fico:\n\n\n\n\nEjemplo de gr√°fico de entrop√≠a espec√≠ficando una prueba Reversa"
  },
  {
    "objectID": "index.html#explicaci√≥n",
    "href": "index.html#explicaci√≥n",
    "title": "C√°lculo de Entropia en el Laberinto Acu√°tico de Morris",
    "section": "Explicaci√≥n",
    "text": "Explicaci√≥n\nEl c√°lculo de entrop√≠a est√° basado en la propuesta de Maei et al., 2009.\nPrimero se obtienen de las distancias que se compone de las coordenadas del animal, las diferencias del animal al punto de referencia (annulus blanco), el cuadrado de la distancia Euclidiana, la distancia Euclidiana y el promedia de la distancia (\\(œÉ_d\\)). Con estos par√°metros, se calcula la distancia del animal a la plataforma en cada tiempo utilizando la distancia Euclidiana tomando en cuenta las coordenadas del animal y de la plataforma planco.\n\\[\nd = \\sqrt{(x_a - x_b) + (y_a - y_b)^2}\n\\]\nLas medias ponderadas y la matriz de varianza-covarianza se obtuvo con el siguiente c√≥digo, donde la matriz de covarianza se construye con las medias ponderadas y la matriz de covarianza de valores Eigen se calcula para obtener la varianza \\(œÉ_a^2\\) y \\(ùúé_b^2\\). Con estos par√°metros vamos a calcular la varianza de los vectores de las distancias del animal respecto a la plataforma.\nLa matriz de covarianza se utiliza para capturar la vraianza y covarianza de los datos en m√°s de una dimensi√≥n. Para el caso de dos dimensiones (coordenadas X y Y), la matriz de covarianza se representa como:\n\\[\nŒ£=\\begin{pmatrix}\nVar(x) & Cov(x,y)\\\\\nCov(x,y) & Var(y)\n\\end{pmatrix}\n\\]\ndonde Var(x) representa la varianza de las coordenadas X, Var(y) representa la varianza de las coordenadas Y, y Cov(x,y) representa la covarianza entre las coordenadas de X y Y. Esta matriz de covarianza resume c√≥mo las coordenadas var√≠an entre ellas. Si las coordenadas X y Y est√°n altamente correlacionadas, la covarianza ser√° alta, indicando una relaci√≥n linear alta.\nLos ejes principales o valores Eigen son las direcciones en las que los datos var√≠an m√°s. Estos ejes se encuentran realizando una descomposici√≥n en valores propios de la matriz de covarianza. Los valores propios y los vectores propios obtenidos de esta descomposici√≥n tienen las siguientes intepretaciones:\n\nValores Propios: Representan la magnitud de la varianza a lo largo de los ejes principales.\nVectores Propios: Indican la direcci√≥n de estos ejes principales.\n\nEstos ejes pueden considerarse como los ejes mayor y menor de una elipse de error que mejor se ajusta a los datos. Ahora, se tiene que sumar los Logaritmos de las varianzas utilizando en el c√°lculo de la entrop√≠a para cuantificar la dispersi√≥n o el desorden de los datos en el plano, reflejando el producto de las varianzas a lo largo de los ejes principales\nPara calcular la media de la distancia al cuadrado y calcular la entrop√≠a, se calcula la media de la distancia al cuadrado (\\(œÉ_2^d\\)). El c√°lculo final de entrop√≠a se obtiene sumando los logaritmos de las medias cuadradas de la distancia y el producto de los valores Eigen. En resumen, calculamos \\(H_{error}\\) basados en la f√≥rmula \\(H_{error} = log(varianza_{distancia})\\), calculamos la varianza de la trayectoria, calculamos la entrop√≠a de la trayectoria, realizamos la operaci√≥n \\(H_{trayectoria} = log(var_{trayectoria})\\) y finalmente calculamos la entrop√≠a total como \\(H_{total} = H_{error} + H_{trayectoria}\\)"
  }
]