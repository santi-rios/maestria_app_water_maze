[
  {
    "objectID": "version_upload_file.html",
    "href": "version_upload_file.html",
    "title": "Entropia",
    "section": "",
    "text": "library(shiny)\n\nWarning: package 'shiny' was built under R version 4.2.3\n\nlibrary(bslib)\n\nWarning: package 'bslib' was built under R version 4.2.3\n\n\n\nAttaching package: 'bslib'\n\n\nThe following object is masked from 'package:utils':\n\n    page\n\n# Define UI for slider demo app ----\nui &lt;- page_sidebar(\n\n  # App title ----\n  title = \"Subir Archivo\",\n\n  # Sidebar panel for inputs ----\n  sidebar = sidebar(\n\n    # Input: Select a file ----\n    fileInput(\n      \"file1\",\n      \"Choose CSV File\",\n      multiple = TRUE,\n      accept = c(\n        \"text/csv\",\n        \"text/comma-separated-values,text/plain\",\n        \".csv\"\n      )\n    ),\n\n    # Horizontal line ----\n    tags$hr(),\n\n    # Input: Checkbox if file has header ----\n    checkboxInput(\"header\", \"Header\", TRUE),\n\n    # Input: Select separator ----\n    radioButtons(\n      \"sep\",\n      \"Separator\",\n      choices = c(\n        Comma = \",\",\n        Semicolon = \";\",\n        Tab = \"\\t\"\n      ),\n      selected = \",\"\n    ),\n\n    # Input: Select quotes ----\n    radioButtons(\n      \"quote\",\n      \"Quote\",\n      choices = c(\n        None = \"\",\n        \"Double Quote\" = '\"',\n        \"Single Quote\" = \"'\"\n      ),\n      selected = '\"'\n    ),\n\n    # Horizontal line ----\n    tags$hr(),\n\n    # Input: Select number of rows to display ----\n    radioButtons(\n      \"disp\",\n      \"Display\",\n      choices = c(\n        Head = \"head\",\n        All = \"all\"\n      ),\n      selected = \"head\"\n    )\n  ),\n\n  # Output: Data file ----\n  tableOutput(\"contents\")\n)\n\n# Define server logic to read selected file ----\nserver &lt;- function(input, output) {\n  output$contents &lt;- renderTable({\n    # input$file1 will be NULL initially. After the user selects\n    # and uploads a file, head of that data file by default,\n    # or all rows if selected, will be shown.\n\n    req(input$file1)\n\n    df &lt;- read.csv(\n      input$file1$datapath,\n      header = input$header,\n      sep = input$sep,\n      quote = input$quote\n    )\n\n    if (input$disp == \"head\") {\n      return(head(df))\n    } else {\n      return(df)\n    }\n  })\n}\n\n# Create Shiny app ----\nshinyApp(ui, server)\n\n\nListening on http://127.0.0.1:6438\n\n\n\n\n\n\n\n\n\nmpgData &lt;- readr::read_csv(‚Äúwater_maze.csv‚Äù)\nmpgData |&gt; dplyr::select(prueba, distancioa_media_blanco, zona_blanco)\nwebr::install(‚Äúggplot2‚Äù) webr::install(‚Äúhtmltools‚Äù)\nhttps://shinylive.io/r/examples/#sliders\nhttps://rstudio.github.io/renv/articles/renv.html\nhttps://quarto.thecoatlessprofessor.com/r-shinylive-demo/\nhttps://github.com/coatless-tutorials/convert-shiny-app-r-shinylive/blob/main/app.R\nhttps://github.com/coatless-textbooks/statistical-concepts-with-shiny-apps/blob/main/index.qmd\nhttps://shiny.posit.co/r/gallery/\nv2\n\nlibrary(shiny)\nlibrary(bslib)\n\n# Define UI for slider demo app ----\nui &lt;- page_sidebar(\n\n  # App title ----\n  title = \"Subir Archivo\",\n\n  # Sidebar panel for inputs ----\n  sidebar = sidebar(\n\n    # Input: Select a file ----\n    fileInput(\n      \"file1\",\n      \"Choose CSV File\",\n      multiple = TRUE,\n      accept = c(\n        \"text/csv\",\n        \"text/comma-separated-values,text/plain\",\n        \".csv\"\n      )\n    ),\n\n    # Horizontal line ----\n    tags$hr(),\n\n    # Input: Checkbox if file has header ----\n    checkboxInput(\"header\", \"Header\", TRUE),\n\n    # Input: Select separator ----\n    # radioButtons(\n    #   \"sep\",\n    #   \"Separator\",\n    #   choices = c(\n    #     Comma = \",\",\n    #     Semicolon = \";\",\n    #     Tab = \"\\t\"\n    #   ),\n    #   selected = \",\"\n    # ),\n\n    # Input: Select quotes ----\n    # radioButtons(\n    #   \"quote\",\n    #   \"Quote\",\n    #   choices = c(\n    #     None = \"\",\n    #     \"Double Quote\" = '\"',\n    #     \"Single Quote\" = \"'\"\n    #   ),\n    #   selected = '\"'\n    # ),\n\n    # Horizontal line ----\n    tags$hr(),\n\n    # Input: Select number of rows to display ----\n    radioButtons(\n      \"disp\",\n      \"Display\",\n      choices = c(\n        Head = \"head\",\n        All = \"all\"\n      ),\n      selected = \"head\"\n    )\n  ),\n  \n  navset_card_underline(\n    # Panel with plot ----\n    nav_panel(\"Plot\", plotOutput(\"plot\")),\n\n    # Panel with summary ----\n    nav_panel(\"Summary\", verbatimTextOutput(\"summary\")),\n\n    # Panel with table ----\n    nav_panel(\"Table\", tableOutput(\"contents\"))\n  )\n\n)\n\n# Define server logic to read selected file ----\nserver &lt;- function(input, output) {\n  output$contents &lt;- renderTable({\n    # input$file1 will be NULL initially. After the user selects\n    # and uploads a file, head of that data file by default,\n    # or all rows if selected, will be shown.\n\n    req(input$file1)\n\n    df &lt;- read.csv(\n      input$file1$datapath,\n      header = input$header\n      # sep = input$sep,\n      # quote = input$quote\n    )\n\n    if (input$disp == \"head\") {\n      return(head(df))\n    } else {\n      return(df)\n    }\n  })\n  # \n  output$plot &lt;- renderPlot({\n    req(input$file1)\n    hist(\n      df(),\n      lty = \"blank\",\n      xlab = \"cruces_blanco\",\n      freq = FALSE,\n      main = \"\",\n      col = \"#75AADB\",\n      border = \"white\"\n    )\n  })\n\n  # Generate a summary of the data ----\n  output$summary &lt;- renderPrint({\n    summary((df))\n  })\n}\n\n# Create Shiny app ----\nshinyApp(ui, server)\n\n\nListening on http://127.0.0.1:3678"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "C√°lculo de Entropia en el Laberinto Acu√°tico de Morris",
    "section": "",
    "text": "Coordenadas de annulus original: (220, 77) Coordenadas de annulus Reversa: (130, 169)\n#| standalone: true\n#| viewerHeight: 600\nlibrary(shiny)\nlibrary(janitor)  # For clean_names\nlibrary(dplyr)    # For data manipulation\nlibrary(car)      # For the ellipse function\n\n# Define UI for app to upload and analyze CSV file\nui &lt;- fluidPage(\n  titlePanel(\"C√°lculo de entrop√≠a\"),\n  sidebarLayout(\n    sidebarPanel(\n      # Input: Select a CSV file\n      fileInput(\"file1\", \"Subir coordenadas\", accept = \".csv\"),\n      \n      # Numeric input for defining plat_x and plat_y\n      numericInput(\"plat_x\", \"Coordenadas de plataforma en X\", value = 220),  # Default value set to 220\n      numericInput(\"plat_y\", \"Coordenadas de plataforma en Y\", value = 77),   # Default value set to 77\n      \n      tags$hr(),\n      \n      # Button to calculate entropy\n      actionButton(\"calc_entropy\", \"Calcular\")\n    ),\n    mainPanel(\n      tableOutput(\"entropy_table\"),\n      plotOutput(\"plot\")  # Output plot\n    )\n  )\n)\n\n# Define server logic\nserver &lt;- function(input, output, session) {\n  observeEvent(input$calc_entropy, {\n    req(input$file1)  # Ensure that a file is uploaded before proceeding\n    \n    # Read the CSV file\n    data &lt;- read.csv(input$file1$datapath)\n    # Clean column names with janitor to ensure consistency\n    data &lt;- janitor::clean_names(data)\n    # Rename the first three columns to 'time', 'X', 'Y'\n    names(data)[1:3] &lt;- c(\"time\", \"X\", \"Y\")\n    \n    # Use input values for plat_x and plat_y\n    plat_x &lt;- input$plat_x\n    plat_y &lt;- input$plat_y\n\n    Xraw &lt;- as.numeric(data$X)\n    Yraw &lt;- as.numeric(data$Y)\n\n    d_x &lt;- Xraw - plat_x\n    d_y &lt;- Yraw - plat_y\n\n    dist2 &lt;- d_x^2 + d_y^2\n\n    w &lt;- 1\n    sw &lt;- sum(w)\n\n    xm &lt;- mean(w * d_x) / sw\n    ym &lt;- mean(w * d_y) / sw\n    xxm &lt;- mean(w * d_x * d_x) / sw\n    yym &lt;- mean(w * d_y * d_y) / sw\n    xym &lt;- mean(w * d_x * d_y) / sw\n\n    Sig &lt;- matrix(c(xxm - xm^2, xym - xm * ym,\n                    xym - xm * ym, yym - ym^2), nrow=2)\n\n    eig_val &lt;- eigen(Sig)$values\n    var_xy2 &lt;- eig_val[1] * eig_val[2]\n\n    mdist2 &lt;- mean(w * dist2) / sw\n\n    entropy &lt;- log(mdist2) + 0.5 * log(var_xy2)\n\n    # Create a data frame for output\n    entropy_data &lt;- data.frame(Entropia = entropy)\n\n    # Output the data frame\n    output$entropy_table &lt;- renderTable({\n      entropy_data\n    })\n\n    # Output the plot\n    output$plot &lt;- renderPlot({\n      # Define limits with a buffer\n      x_lim_buffer &lt;- 100\n      y_lim_buffer &lt;- 100\n      plot(Xraw, Yraw, xlim=c(min(Xraw) - x_lim_buffer, max(Xraw) + x_lim_buffer), ylim=c(min(Yraw) - y_lim_buffer, max(Yraw) + y_lim_buffer), xlab=\"X\", ylab=\"Y\", main=\"Coordenadas del rat√≥n alrededor del annulus blanco\")\n      points(plat_x, plat_y, col=\"red\", pch=19)  # Reference point\n      segments(Xraw, Yraw, plat_x, plat_y, col=\"grey\")\n      text(plat_x, plat_y, labels=\"Annulus\", pos=4, col=\"red\")\n\n      # Draw error ellipse and principal axes\n      data_points &lt;- data.frame(Xraw, Yraw)\n      ellipse_center &lt;- c(plat_x, plat_y)\n      cov_matrix &lt;- cov(data_points)\n\n      eig &lt;- eigen(cov_matrix)\n      eig_vec &lt;- eig$vectors\n      eig_val &lt;- eig$values\n\n      # Scale eigenvectors for plotting\n      scale_factor &lt;- 2\n      segments(plat_x, plat_y, plat_x + scale_factor * eig_vec[1,1] * sqrt(eig_val[1]), plat_y + scale_factor * eig_vec[2,1] * sqrt(eig_val[1]), col=\"purple\")\n      segments(plat_x, plat_y, plat_x + scale_factor * eig_vec[1,2] * sqrt(eig_val[2]), plat_y + scale_factor * eig_vec[2,2] * sqrt(eig_val[2]), col=\"purple\")\n    })\n  })\n}\n\n\n# Create Shiny app\nshinyApp(ui, server)"
  },
  {
    "objectID": "index.html#c√°lculo",
    "href": "index.html#c√°lculo",
    "title": "C√°lculo de Entropia en el Laberinto Acu√°tico de Morris",
    "section": "",
    "text": "Coordenadas de annulus original: (220, 77) Coordenadas de annulus Reversa: (130, 169)\n#| standalone: true\n#| viewerHeight: 600\nlibrary(shiny)\nlibrary(janitor)  # For clean_names\nlibrary(dplyr)    # For data manipulation\nlibrary(car)      # For the ellipse function\n\n# Define UI for app to upload and analyze CSV file\nui &lt;- fluidPage(\n  titlePanel(\"C√°lculo de entrop√≠a\"),\n  sidebarLayout(\n    sidebarPanel(\n      # Input: Select a CSV file\n      fileInput(\"file1\", \"Subir coordenadas\", accept = \".csv\"),\n      \n      # Numeric input for defining plat_x and plat_y\n      numericInput(\"plat_x\", \"Coordenadas de plataforma en X\", value = 220),  # Default value set to 220\n      numericInput(\"plat_y\", \"Coordenadas de plataforma en Y\", value = 77),   # Default value set to 77\n      \n      tags$hr(),\n      \n      # Button to calculate entropy\n      actionButton(\"calc_entropy\", \"Calcular\")\n    ),\n    mainPanel(\n      tableOutput(\"entropy_table\"),\n      plotOutput(\"plot\")  # Output plot\n    )\n  )\n)\n\n# Define server logic\nserver &lt;- function(input, output, session) {\n  observeEvent(input$calc_entropy, {\n    req(input$file1)  # Ensure that a file is uploaded before proceeding\n    \n    # Read the CSV file\n    data &lt;- read.csv(input$file1$datapath)\n    # Clean column names with janitor to ensure consistency\n    data &lt;- janitor::clean_names(data)\n    # Rename the first three columns to 'time', 'X', 'Y'\n    names(data)[1:3] &lt;- c(\"time\", \"X\", \"Y\")\n    \n    # Use input values for plat_x and plat_y\n    plat_x &lt;- input$plat_x\n    plat_y &lt;- input$plat_y\n\n    Xraw &lt;- as.numeric(data$X)\n    Yraw &lt;- as.numeric(data$Y)\n\n    d_x &lt;- Xraw - plat_x\n    d_y &lt;- Yraw - plat_y\n\n    dist2 &lt;- d_x^2 + d_y^2\n\n    w &lt;- 1\n    sw &lt;- sum(w)\n\n    xm &lt;- mean(w * d_x) / sw\n    ym &lt;- mean(w * d_y) / sw\n    xxm &lt;- mean(w * d_x * d_x) / sw\n    yym &lt;- mean(w * d_y * d_y) / sw\n    xym &lt;- mean(w * d_x * d_y) / sw\n\n    Sig &lt;- matrix(c(xxm - xm^2, xym - xm * ym,\n                    xym - xm * ym, yym - ym^2), nrow=2)\n\n    eig_val &lt;- eigen(Sig)$values\n    var_xy2 &lt;- eig_val[1] * eig_val[2]\n\n    mdist2 &lt;- mean(w * dist2) / sw\n\n    entropy &lt;- log(mdist2) + 0.5 * log(var_xy2)\n\n    # Create a data frame for output\n    entropy_data &lt;- data.frame(Entropia = entropy)\n\n    # Output the data frame\n    output$entropy_table &lt;- renderTable({\n      entropy_data\n    })\n\n    # Output the plot\n    output$plot &lt;- renderPlot({\n      # Define limits with a buffer\n      x_lim_buffer &lt;- 100\n      y_lim_buffer &lt;- 100\n      plot(Xraw, Yraw, xlim=c(min(Xraw) - x_lim_buffer, max(Xraw) + x_lim_buffer), ylim=c(min(Yraw) - y_lim_buffer, max(Yraw) + y_lim_buffer), xlab=\"X\", ylab=\"Y\", main=\"Coordenadas del rat√≥n alrededor del annulus blanco\")\n      points(plat_x, plat_y, col=\"red\", pch=19)  # Reference point\n      segments(Xraw, Yraw, plat_x, plat_y, col=\"grey\")\n      text(plat_x, plat_y, labels=\"Annulus\", pos=4, col=\"red\")\n\n      # Draw error ellipse and principal axes\n      data_points &lt;- data.frame(Xraw, Yraw)\n      ellipse_center &lt;- c(plat_x, plat_y)\n      cov_matrix &lt;- cov(data_points)\n\n      eig &lt;- eigen(cov_matrix)\n      eig_vec &lt;- eig$vectors\n      eig_val &lt;- eig$values\n\n      # Scale eigenvectors for plotting\n      scale_factor &lt;- 2\n      segments(plat_x, plat_y, plat_x + scale_factor * eig_vec[1,1] * sqrt(eig_val[1]), plat_y + scale_factor * eig_vec[2,1] * sqrt(eig_val[1]), col=\"purple\")\n      segments(plat_x, plat_y, plat_x + scale_factor * eig_vec[1,2] * sqrt(eig_val[2]), plat_y + scale_factor * eig_vec[2,2] * sqrt(eig_val[2]), col=\"purple\")\n    })\n  })\n}\n\n\n# Create Shiny app\nshinyApp(ui, server)"
  },
  {
    "objectID": "index.html#explicaci√≥n",
    "href": "index.html#explicaci√≥n",
    "title": "C√°lculo de Entropia en el Laberinto Acu√°tico de Morris",
    "section": "Explicaci√≥n",
    "text": "Explicaci√≥n\nEl c√°lculo de entrop√≠a est√° basado en la propuesta de Maei et al., 2009.\nPrimero se obtienen de las distancias que se compone de las coordenadas del animal, las diferencias del animal al punto de referencia (annulus blanco), el cuadrado de la distancia Euclidiana, la distancia Euclidiana y el promedia de la distancia (\\(œÉ_d\\)). Con estos par√°metros, se calcula la distancia del animal a la plataforma en cada tiempo utilizando la distancia Euclidiana tomando en cuenta las coordenadas del animal y de la plataforma planco.\n\\[\nd = \\sqrt{(x_a - x_b) + (y_a - y_b)^2}\n\\]\nLas medias ponderadas y la matriz de varianza-covarianza se obtuvo con el siguiente c√≥digo, donde la matriz de covarianza se construye con las medias ponderadas y la matriz de covarianza de valores Eigen se calcula para obtener la varianza \\(œÉ_a^2\\) y \\(ùúé_b^2\\). Con estos par√°metros vamos a calcular la varianza de los vectores de las distancias del animal respecto a la plataforma.\nLa matriz de covarianza se utiliza para capturar la vraianza y covarianza de los datos en m√°s de una dimensi√≥n. Para el caso de dos dimensiones (coordenadas X y Y), la matriz de covarianza se representa como:\n\\[\nŒ£=\\begin{pmatrix}\nVar(x) & Cov(x,y)\\\\\nCov(x,y) & Var(y)\n\\end{pmatrix}\n\\]\ndonde Var(x) representa la varianza de las coordenadas X, Var(y) representa la varianza de las coordenadas Y, y Cov(x,y) representa la covarianza entre las coordenadas de X y Y. Esta matriz de covarianza resume c√≥mo las coordenadas var√≠an entre ellas. Si las coordenadas X y Y est√°n altamente correlacionadas, la covarianza ser√° alta, indicando una relaci√≥n linear alta.\nLos ejes principales o valores Eigen son las direcciones en las que los datos var√≠an m√°s. Estos ejes se encuentran realizando una descomposici√≥n en valores propios de la matriz de covarianza. Los valores propios y los vectores propios obtenidos de esta descomposici√≥n tienen las siguientes intepretaciones:\n\nValores Propios: Representan la magnitud de la varianza a lo largo de los ejes principales.\nVectores Propios: Indican la direcci√≥n de estos ejes principales.\n\nEstos ejes pueden considerarse como los ejes mayor y menor de una elipse de error que mejor se ajusta a los datos. Ahora, se tiene que sumar los Logaritmos de las varianzas utilizando en el c√°lculo de la entrop√≠a para cuantificar la dispersi√≥n o el desorden de los datos en el plano, reflejando el producto de las varianzas a lo largo de los ejes principales\nPara calcular la media de la distancia al cuadrado y calcular la entrop√≠a, se calcula la media de la distancia al cuadrado (\\(œÉ_2^d\\)). El c√°lculo final de entrop√≠a se obtiene sumando los logaritmos de las medias cuadradas de la distancia y el producto de los valores Eigen. En resumen, calculamos \\(H_{error}\\) basados en la f√≥rmula \\(H_{error} = log(varianza_{distancia})\\), calculamos la varianza de la trayectoria, calculamos la entrop√≠a de la trayectoria, realizamos la operaci√≥n \\(H_{trayectoria} = log(var_{trayectoria})\\) y finalmente calculamos la entrop√≠a total como \\(H_{total} = H_{error} + H_{trayectoria}\\)"
  }
]